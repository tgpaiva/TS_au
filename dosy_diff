AUERR = dosy(curdat);
QUIT

#include <ShapeIO/ShapeIOC.h>

/*  Define some constants and variables         */
#define MAX_POINTS  4096
#define TLL 1024
const   int debugflag=0;

static int getshapescale(const char*, double*);
static int scale_gradshape(const char*, double);
static int trev_gradshape(const char*);


int dosy(const char* curdat)
{
int     diffpoints=0, restore=0, fnmod1, fnmod2=0, pmod, nShapePoints;
float   gstart, gstop;
double  shapescale=0.63662, gcalib=53.5, minAmp, maxAmp, integFac;
double* phPtr;
double*	value;
char    text[TLL], path[PATH_MAX];
char    rampname[TLL], shapename[TLL], stcmd[TLL], unit[TLL];
const   char* ramptype = "l";
const   char* answer = "n";
const   char* rga = "n";
const   char* nospool = "n";
FILE*   fptr;


FETCHPAR("PARMODE",&pmod)
if ( (pmod < 1) || (pmod > 2) )
   STOPMSG("Not a 2D or 3D dataset");

if (pmod == 1)      /* 2D */
   {
   FETCHPAR1("FnMODE",&fnmod1)
   if (fnmod1 != 1)
       STOPMSG("FnMODE must be QF in diffusion dimension (F1)")
   FETCHPAR1("TD",&diffpoints)
   }

if (pmod == 2)      /* 3D */
   {
   FETCHPAR1("FnMODE",&fnmod2);        /* F2 */
   FETCHPAR3("FnMODE",&fnmod1);        /* F1 */
   if ( (fnmod1 != 1) && (fnmod2 != 1) )
       STOPMSG("FnMODE must be QF in diffusion dimension")

   if (fnmod2 == 1)    { FETCHPAR1("TD",&diffpoints) }
   else                { FETCHPAR3("TD",&diffpoints) }
   }


/*  get shapescale value    */
FETCHPAR("GPNAM 6",shapename)

if (strcmp(shapename,"Difftrap") == 0)
   {
   XAU("difftrap", "")
   ERRORABORT
   }

if (getshapescale(shapename, &shapescale) < 0)  return -1;


/*  evaluate command line or ask for parameters     */
if (i_argc > 2  &&  strcmp(i_argv[2], "restore") == 0)
   restore = 1;

if (i_argc <= 5  &&  restore == 0)
   {
   gstart=0.06;
   gstop=2.94;
   Proc_err(DEF_ERR_OPT,"Define the gradient ramp for shape\n%s (Integral = %.3f)",
        shapename, shapescale);
   GETFLOAT("Enter first gradient amplitude:  ", gstart )
   GETFLOAT("Enter final gradient amplitude:  ", gstop )
   GETINT("Enter number of points:", diffpoints )
   strcpy(rampname, ramptype);
   GETSTRING("ramp type (l q e {linear/squared/exponential} ):  ", rampname )
   ramptype = rampname;
   answer = "q";
   }
else
   {
   if (restore)
       {
       FETCHPAR("CNST 20",&gstart)
       FETCHPAR("CNST 21",&gstop)
       if (gstop < 0)
           {
           gstop = -gstop;
           if (gstart < 0)
               {
               gstart = -gstart;
               ramptype = "e";
               }
           else
               {
               ramptype = "q";
               }
           }
       else
           {
           ramptype = "l";
           }

       Proc_err(DEF_ERR_OPT,
           "Gradient ramp (%s) from %.1f to %.1f in %d steps restored",
           ramptype,gstart,gstop,diffpoints);
       }
   else
       {
       gstart = atof(i_argv[2]);
       gstop  = atof(i_argv[3]);
       diffpoints = atoi(i_argv[4]);
       ramptype = i_argv[5];

       if (i_argc > 6)
           answer = i_argv[6];
       if (i_argc > 7)
           rga = i_argv[7];
       if (i_argc > 8)
           nospool = i_argv[8];
       }
   }


/*  Check for legal number of points    */
if ((gstart > gstop) ||
   (gstop > 100) ||
   (diffpoints <= 0) ||
   (diffpoints > MAX_POINTS))
   STOPMSG("illegal arguments")


/*  calculate ramp and store shape using shapetool  */
switch(ramptype[0])
   {
   case 'l' :  {
               sprintf(stcmd,"st generate Ramp %d false %.1f %.1f filename=Difframp", diffpoints, gstart, gstop);
               XCMD(stcmd)
               ERRORABORT
               sprintf(stcmd,"st generate Ramp %d false %.1f %.1f filename=DifframpR", diffpoints, gstop, gstart);
               XCMD(stcmd)
               ERRORABORT

               STOREPAR("CNST 20", gstart)
               STOREPAR("CNST 21", gstop)
               sprintf(text,"lin G (%d points)",diffpoints);
               STOREPAR("EXP",text)
               }
               break;

   case 'q' :  {
               sprintf(stcmd,"st generate QRamp %d false %.1f %.1f filename=Difframp", diffpoints, gstart, gstop);
               XCMD(stcmd)
               ERRORABORT
               sprintf(stcmd,"st generate QRamp %d false %.1f %.1f filename=DifframpR", diffpoints, gstop, gstart);
               XCMD(stcmd)
               ERRORABORT

               STOREPAR("CNST 20", gstart)
               STOREPAR("CNST 21", -gstop)
               sprintf(text,"lin Q (square, %d points)",diffpoints);
               STOREPAR("EXP",text)
               }
               break;

   case 'e' :  {
               sprintf(stcmd,"st generate Efunc %d false %f filename=Difframp", diffpoints, gstart*100.0/gstop);
               XCMD(stcmd)
               ERRORABORT
               if (scale_gradshape("Difframp", gstop) < 0)   return -1;
               if (trev_gradshape("Difframp") < 0)   return -1;

               sprintf(stcmd,"st generate Efunc %d false %f filename=DifframpR", diffpoints, gstart*100.0/gstop);
               XCMD(stcmd)
               ERRORABORT
               if (scale_gradshape("DifframpR", gstop) < 0)   return -1;

               STOREPAR("CNST 20", -gstart)
               STOREPAR("CNST 21", -gstop)
               sprintf(text,"exp G (%d points)",diffpoints);
               STOREPAR("EXP",text)
               }
               break;

   default  :  STOPMSG("illegal ramp type")
   }


/*  read gradient ramp values (just created by stcmd) for conversion to gradient strength    */
if (getParfileDirForRead("Difframp", GP_DIRS, path) < 0)
{
   Proc_err(DEF_ERR_OPT, "%s: %s", "Difframp", path);
   return -1;
}

value = readShapeC(path, &nShapePoints, &phPtr, &minAmp, &maxAmp, &integFac);
if (value == 0)
   Proc_err(DEF_ERR_OPT,"cannot open ramp file for reading\n%s", path);


/*  get gradient calibration    */
sprintf(path, "%s/conf/instr/gradient_calib", PathXWinNMRInst());
if ((fptr = fopen(path, "r")) != 0 )
   {
   if (fscanf(fptr, "%lf %s", &gcalib, unit) == 2)
       {
       if (strcmp(unit,"G/cm") != 0)
           {
           if (strcmp(unit,"G/mm") == 0)
               gcalib*=10;
           else
               gcalib=53.5;
           }
       if (answer[0] != 'y' && gcalib <= 10.0)
           {
           Proc_err(ERRORH_OPT, "gradient calibration may be wrong\n%.4f G/cm", gcalib);
           }
       }
   else
       {
       gcalib=53.5;
       }
   fclose( fptr );
   }


/*  open difflist file    */
if ((fptr = fopen(ACQUPATH("difflist"), "wt")) == 0)
   STOPMSG("Cannot create difflist")


/*  store difflist with gradient strength values        */
TIMES(diffpoints)
   fprintf(fptr, "%.3f\n", value[loopcount1] * shapescale * gcalib);
END

deleteShapeC();
fclose(fptr);

STOREPAR("GPZ 6",100.0)


if (pmod == 1)  { STOREPAR1("TD",diffpoints) }
if (pmod == 2)
   {
   if (fnmod2 == 1) { STOREPAR1("TD",diffpoints) }
   else             { STOREPAR3("TD",diffpoints) }
   }

Show_meta(SM_RAWP);

if (i_argc <= 2)
   {
   Proc_err(DEF_ERR_OPT, "Gradient ramp from %.1f to %.1f written", gstart, gstop);
   }

if (answer[0] == 'n') STOP

if (answer[0] != 'y')
   {
   if (Proc_err(ERROPT_AK_CAN, "Do you want to start acquisition ?") != 0)
       STOP
   }

if (nospool[0] == 'y')
   {
   if (rga[0] == 'y')  RGA
   ZG_OVERWRITE
   }
else
   {
   if (rga[0] == 'y')
       XCMD("sendgui rga")

   XCMD("sendgui zg yes")
   }
return 0;
}


/* subroutines ****************************************************************/
static int getshapescale(const char* shapename, double* scal)
{
char    path[PATH_MAX];

if (getParfileDirForRead(shapename, GP_DIRS, path) < 0)
   {
   Proc_err(DEF_ERR_OPT, "%s: %s", shapename, path);
   return -1;
   }

*scal = getIntegFacC(path);

if (debugflag > 0) {
   Proc_err(ERROPT_AK_OK,"DEBUG\nshapename = %s\nshape integfactor = %.2f", shapename, *scal); }

return 0;
} /* end subroutine */


static int scale_gradshape(const char* gradname, double fact)
{
const   double *inputData;
const   double *phaseData = 0;
int     size, mode;
char    fname[PATH_MAX],text[TLL];

if (getParfileDirForRead(gradname, GP_DIRS, fname) < 0)
   {
   Proc_err(DEF_ERR_OPT, "%s: %s", gradname, fname);
   return -1;
   }

sprintf(text, "%f, false", fact);

inputData = manipulateShapeC(fname, "scale", text, 0, &phaseData, &size, &mode);
if (inputData)
   {
   if (writeShapeC(fname, inputData, size, 0, 0, 0) == 0)
       {
       Proc_err(DEF_ERR_OPT, "write gradient ramp file failed:\n%s", fname);
       ABORT
       }
   }

return 0;
} /* end subroutine */


static int trev_gradshape(const char* gradname)
{
const   double *inputData;
const   double *phaseData = 0;
int     size, mode;
char    fname[PATH_MAX],text[TLL];

if (getParfileDirForRead(gradname, GP_DIRS, fname) < 0)
   {
   Proc_err(DEF_ERR_OPT, "%s: %s", gradname, fname);
   return -1;
   }

sprintf(text, "1.0, false");

inputData = manipulateShapeC(fname, "trev", text, 0, &phaseData, &size, &mode);
if (inputData)
   {
   if (writeShapeC(fname, inputData, size, 0, 0, 0) == 0)
       {
       Proc_err(DEF_ERR_OPT, "write gradient ramp file failed:\n%s", fname);
       ABORT
       }
   }

return 0;
} /* end subroutine */